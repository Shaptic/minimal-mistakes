<!DOCTYPE html>
<html>

<head>
    
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">

<title>
Optimizing Sessionless Sessions - Bits, Bytes, Late Nights
</title>




<link rel="shortcut icon" href="/assets/pic.png">








<link rel="stylesheet" href="/css/main.min.73060ff7591a1707f7b1da8be57462f8d262ed15f545aaec5fb3af1bbb7118c8.css" integrity="sha256-cwYP91kaFwf3sdqL5XRi&#43;NJi7RX1RarsX7OvG7txGMg=" crossorigin="anonymous" media="screen">



 

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\[','\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
           extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
  });
</script>


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Optimizing Sessionless Sessions"/>
<meta name="twitter:description" content="Or, arriving at the rationale behind the existence of JSON Web Tokens."/>

<meta property="og:title" content="Optimizing Sessionless Sessions" />
<meta property="og:description" content="Or, arriving at the rationale behind the existence of JSON Web Tokens." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://teapowered.dev/posts/sessionless-sessions/" />
<meta property="article:published_time" content="2017-12-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-12-20T00:00:00+00:00" />




    

    
    
    
    <title>
        
        Optimizing Sessionless Sessions
        
    </title>
</head>

<body>
    <div class="wrap">
        
            
                <div class="section top-menu">
                    
<p>

    
    <a href="https://teapowered.dev/">
        home</a>

    
        
            &#183;
            <a href="/posts">
                thoughts</a>
        

        
            
                &#183;
                <a href="/recipes">
                    recipes</a>
            
                &#183;
                <a href="/notes">
                    notes</a>
            
                &#183;
                <a href="/about">
                    me</a>
            
        
    
</p>

                </div>
            
        

        <div class="section" id="title">Optimizing Sessionless Sessions</div>

        
<div class="section" id="content">
    December 12 &#183; 1220 words
    
    <hr/>
    <p>I'm currently developing an app as a side-project. This is my first time developing a full-fledged application that requires both a back-end server to store data (for which I've chosen <a href="http://flask.pocoo.org/">Flask</a>) and a front-end client that users interact with (for which I've chosen <a href="https://www.qt.io/">Qt</a>). I've reached the stage at which I need to add authentication, so that different users can query different data from the server (like a Twitter feed is different depending on who you're logged in as).</p>
<p>This post is a look into the research and design that I put into the authentication scheme for the app.</p>
<h1 id="authentication-methods">Authentication Methods</h1>
<p>For authenticating and tracking users and their respective logins, there are many standard approaches:</p>
<ul>
<li>Session management with cookies</li>
<li>OAuth 2.0, or other token-based authentication methods</li>
<li>HTTP's &ldquo;basic authentication&rdquo; support</li>
<li>Additional query parameters</li>
</ul>
<p>I'm only going to touch on the first two methods, and go into detail of the token-based authentication method I'll be using.</p>
<h1 id="session-cookies">Session Cookies</h1>
<p>In general, sessions are used to store per-user information, such as the
contents of your shopping cart, online documents, or other long-term data.
Cookies are probably the most wide-spread approach for most applications. In
this implementation, the server issues a unique ID as a cookie when you make a
request:</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#8b008b;font-weight:bold">HTTP</span>/<span style="color:#b452cd">1.1</span> <span style="color:#b452cd">200</span> <span style="color:#008b45;font-weight:bold">OK</span>
Content-Type: text/html; charset=utf-8
Content-Length: 84
Set-Cookie: session=7dbbb1c5-89f4-4b0a-8196-0e91031042a8; Expires=Sat, 20-Jan-2018 12:52:37 GMT; HttpOnly; Path=/
Date: Wed, 20 Dec 2017 12:52:37 GMT
</code></pre></div><p>Here, the cookie is <code>session=7dbbb1c5-89f4-...</code>, etc. If you include this data
with any subsequent requests to the server, it will know that you are the same
person as before.</p>
<h3 id="why-theyre-no-good">Why They're No Good</h3>
<p>The primary downside to this method is that now the server needs to remember the session cookies that it has distributed (i.e. for every user). This is an increase in necessary resources over time.</p>
<p>For my purposes, I wasn't concerned with this, as I don't expect my application to have that many users. The thing that <em>did</em> concern me was the fact that Qt <a href="https://stackoverflow.com/a/15453429">doesn't have support</a> for modifying cookies from QML JavaScript code&hellip; This would mean I'd need to (re)write all of my requests in C++, which I really don't feel like doing. This led to an interesting investigation into alternative authentication methods that didn't rely on session cookies!</p>
<h1 id="token-authentication">Token Authentication</h1>
<p>This investigation led me to research a <em>purely stateless</em> method, which
authenticates via a cryptographically-signed token. By <em>stateless</em> I mean that
the server does not remember anything between requests. This is an improvement
over <a href="#session-cookies">session cookies</a> because the server doesn't need to
track the cookie data. It comes with its own tradeoff, though, since the state
needs to be &ldquo;rebuilt&rdquo; for every request instead of stored once.</p>
<p>Upon logging in, the server responds with a unique token that can only be associated with that particular user. Before getting technical, assume that a user logs in like so:</p>
<pre><code>Username: george
Password: hunter2
</code></pre>
<p>And the server responds with a unique token:</p>
<pre><code>Token: 2retnuhegroeg
</code></pre>
<p>This can <em>only</em> be associated with this particular user.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> Obviously you
wouldn't use this as a token, since it clearly exposes the username and
password if anyone else were to see it, but the point stands. Any request can
include this value as a token and the server will know that this person is
logged in as &ldquo;george&rdquo;. We can achieve the same effect in a secure way using
cryptography.</p>
<h3 id="message-authentication-codes">Message Authentication Codes</h3>
<p>This section gets pretty technical, but I will try to make things simple for those not familiar with cryptography.</p>
<p>An <a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a>, or hash-based message authentication code, is used to create a one-way association between a value and another unique value. One-way means that the unique value is <em>no longer associatable with the original value</em>. To create an HMAC, you start with the value you wish to convert and some secret value, then run them through a hashing algorithm.</p>
<p>For example, using <a href="https://www.freeformatter.com/hmac-generator.html">this
tool</a>, the HMAC of the value
&ldquo;george&rdquo; with the secret key &ldquo;secret&rdquo; using the MD5 hashing algorithm is
<code>b94624b9274af8d0843d8dea6108577a</code>. This is something that will always be true, and the original value is completely indeterminable from the HMAC (well, aside from the fact that I just told you they were associated).<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>From now on, we'll refer to this resulting unique, one-way HMAC value as the
<strong>token</strong>.</p>
<p>Now, how do we use these for sessions? We will create these tokens based on the login data! The user logs in as usual sending their username and password, and the server responds with the user ID and the token:<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
<p>[
t = \text{HMAC}_{s}\left(u ,|, p\right)
]</p>
<p>Where $t$ is the resulting token, $s$ is the secret key that only the server knows, and $u, p$ are the username and password, respectively.</p>
<div class="notice info">
  <strong>An Aside on User IDs</strong><br>
Whether using this authentication method or not, the user is stored in a database where (for simplicity) a user's ID is represented its row number in a table. In our running example, pretend that this is the user's row: <code>5 | &quot;george&quot; | &quot;hunter2&quot;</code>, so <strong>the user ID is 5</strong>.
</div>
<p>Then, with <em>every subsequent request</em>, we send the token and the user ID (instead of the login info) as part of our request using the <code>X-Auth-Token</code> header (which is just part of the HTTP request):</p>
<pre><code>X-Auth-Token: id=5;token=090b4d082bd7adc1b223086d1d9f8dc4
</code></pre><p>Both of these pieces of information are critical for the server to believe we are who we say we are. The token alone isn't enough; it's a one-way value, so it <em>only</em> proves that we logged in successfully at some point in time. Hence, the user ID is also necessary so that the server also knows <em>who</em> we are. Then, the server can then verify the token by calculating it themselves. They know the credentials associated with the ID, and they know the secret, so they can follow the same formula and make sure the tokens match.</p>
<p>Why is this secure? Because <strong>users don't know the server's secret,</strong> so they can't fake tokens. The only way they can acquire a valid one is by successfully logging into the server.</p>
<h1 id="conclusion">Conclusion</h1>
<p>With this method, we can have fully memory-less sessions. This improves scalability, and also lets us do some fancy cryptography. It comes with the price that we now have to query the database whenever we need something (like the user information), so we can't do any session caching, but it also comes with the benefit that, well, we don't have to do any session caching.</p>
<p>Most importantly, though, it means I don't need to rewrite my requests and callbacks in C++ in my Qt front-end.</p>
<p>If you want to use a robust, standardized solution, you can look into JSON Web
Tokens (JWTs). For me, though, this simple solution is more than enough to
provide authentication for my application.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Obviously this isn't strictly true. Consider <code>Username: georgeh</code> and
<code>Password: unter2</code>; this combination would likewise result in the same token.
It's just an analogy to avoid getting mathy.<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>For the value to be truly indeterminable, you need to use a cryptographically-secure hashing algorithm like SHA256 (rather than MD5, which is known to be breakable). Here, the resulting HMAC would've been too long and scary-looking, so I used MD5 for a simpler example.<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>The $|$ operator here is concatenation, just slapping the two
values together.<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>You should <em>never</em> store a password in plaintext, so the token should
actually use the <em>hashed</em> password $H(p)$.<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
</ol>
</section>

</div>


        
<div class="section bottom-menu">
    
<hr />
<p>

    
    <a href="https://teapowered.dev/">
        home</a>

    
        
            &#183;
            <a href="/posts">
                thoughts</a>
        

        
            
                &#183;
                <a href="/recipes">
                    recipes</a>
            
                &#183;
                <a href="/notes">
                    notes</a>
            
                &#183;
                <a href="/about">
                    me</a>
            
        
    
</p>

</div>


        <div class="section footer"></div>
    </div>
</body>

</html>
